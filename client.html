<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Project Diva Controller</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a2e;
        }
        #container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        #slider-zone {
            height: 15%;
            background: linear-gradient(180deg, #f4d03f 0%, #c9a227 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: #333;
            font-family: sans-serif;
            border-bottom: 3px solid #333;
        }
        #button-zone {
            flex: 1;
            display: flex;
        }
        .button {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            font-weight: bold;
            font-family: sans-serif;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            border-right: 2px solid #333;
            transition: filter 0.05s;
        }
        .button:last-child {
            border-right: none;
        }
        .button.active {
            filter: brightness(1.3);
        }
        #triangle {
            background: linear-gradient(180deg, #27ae60 0%, #1e8449 100%);
        }
        #square {
            background: linear-gradient(180deg, #e91e63 0%, #ad1457 100%);
        }
        #cross {
            background: linear-gradient(180deg, #2196f3 0%, #1565c0 100%);
        }
        #circle {
            background: linear-gradient(180deg, #f44336 0%, #c62828 100%);
        }
        #status {
            position: fixed;
            top: 5px;
            right: 5px;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
        }
        .connected { background: #27ae60; color: white; }
        .disconnected { background: #e74c3c; color: white; }
        .symbol {
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="slider-zone">↔ SLIDE ↔</div>
        <div id="button-zone">
            <div class="button" id="triangle" data-zone="triangle">
                <span class="symbol">△</span>
            </div>
            <div class="button" id="square" data-zone="square">
                <span class="symbol">□</span>
            </div>
            <div class="button" id="cross" data-zone="cross">
                <span class="symbol">✕</span>
            </div>
            <div class="button" id="circle" data-zone="circle">
                <span class="symbol">○</span>
            </div>
        </div>
    </div>
    <div id="status" class="disconnected">Connecting...</div>

    <script>
        const sliderZone = document.getElementById('slider-zone');
        const buttons = document.querySelectorAll('.button');
        const status = document.getElementById('status');

        let ws = null;
        let touches = new Map();
        let lastPositions = new Map();

        function connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${location.host}/ws`);

            ws.onopen = () => {
                status.textContent = 'Connected';
                status.className = 'connected';
            };

            ws.onclose = () => {
                status.textContent = 'Disconnected';
                status.className = 'disconnected';
                setTimeout(connect, 1000);
            };

            ws.onerror = () => {
                ws.close();
            };
        }

        function send(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            }
        }

        function getZone(x, y) {
            const rect = document.getElementById('button-zone').getBoundingClientRect();
            if (y < rect.top) {
                return 'slider';
            }
            const buttonWidth = rect.width / 4;
            const relX = x - rect.left;
            if (relX < buttonWidth) return 'triangle';
            if (relX < buttonWidth * 2) return 'square';
            if (relX < buttonWidth * 3) return 'cross';
            return 'circle';
        }

        function updateButtonVisuals() {
            const activeZones = new Set();
            touches.forEach(t => activeZones.add(t.zone));

            buttons.forEach(btn => {
                if (activeZones.has(btn.dataset.zone)) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function handleTouchStart(e) {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const zone = getZone(touch.clientX, touch.clientY);
                const touchData = {
                    id: touch.identifier,
                    x: touch.clientX,
                    y: touch.clientY,
                    zone: zone,
                    startTime: Date.now()
                };
                touches.set(touch.identifier, touchData);
                lastPositions.set(touch.identifier, { x: touch.clientX, y: touch.clientY, time: Date.now() });

                if (zone !== 'slider') {
                    send({ type: 'start', id: touch.identifier, x: touch.clientX, y: touch.clientY, zone: zone });
                }
            }
            updateButtonVisuals();
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const now = Date.now();

            for (const touch of e.changedTouches) {
                const last = lastPositions.get(touch.identifier);
                if (last) {
                    const dt = (now - last.time) / 1000;
                    if (dt > 0) {
                        const vx = (touch.clientX - last.x) / (window.innerWidth * dt);

                        // Detect slide
                        if (Math.abs(vx) > 0.5) {
                            send({ type: 'slide', id: touch.identifier, x: touch.clientX, y: touch.clientY, zone: 'slider', vx: vx });
                        }
                    }
                }
                lastPositions.set(touch.identifier, { x: touch.clientX, y: touch.clientY, time: now });
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const touchData = touches.get(touch.identifier);
                if (touchData && touchData.zone !== 'slider') {
                    send({ type: 'end', id: touch.identifier, x: touch.clientX, y: touch.clientY, zone: touchData.zone });
                }
                touches.delete(touch.identifier);
                lastPositions.delete(touch.identifier);
            }
            updateButtonVisuals();
        }

        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        document.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        // Prevent zoom
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        document.addEventListener('gestureend', e => e.preventDefault());

        // Request fullscreen on first touch (for iOS)
        let requestedFullscreen = false;
        document.addEventListener('touchstart', () => {
            if (!requestedFullscreen && document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(() => {});
                requestedFullscreen = true;
            }
        }, { once: true });

        connect();
    </script>
</body>
</html>
